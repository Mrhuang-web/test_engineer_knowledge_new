# 性能测试基础指南

## 一、什么是性能测试？

性能测试是通过模拟真实用户场景，测试系统在不同负载下的性能表现，评估系统的响应速度、稳定性、可靠性和资源利用率，找出系统瓶颈并优化。

## 二、核心参数详细解释

### 1. 响应时间（Response Time）
- **定义**：从你点击鼠标发送请求，到看到完整响应的总时间
- **单位**：毫秒（ms）
- **举个例子**：打开百度首页用了150ms，就是响应时间
- **分类**：
  - 平均响应时间：所有请求的平均等待时间
  - P50（中位数）：50%的请求响应时间≤这个值（比如P50=200ms，说明一半请求在200ms内完成）
  - P90：90%的请求响应时间≤这个值（更严格，反映大多数用户体验）
  - P95：95%的请求响应时间≤这个值
  - P99：99%的请求响应时间≤这个值（最严格，反映极端情况）
- **正常范围**：
  - 网页：P95≤2秒（用户可接受）
  - API：P95≤500毫秒（移动端要求更高）
- **影响因素**：网络延迟、服务器处理速度、数据库查询时间

### 2. 吞吐量（Throughput）
- **定义**：系统每秒能处理多少个请求
- **单位**：
  - TPS：每秒处理的业务事务数（一个事务可能包含多个请求，比如登录是一个事务，包含输入、验证、跳转多个请求）
  - RPS：每秒处理的请求数（单个HTTP请求）
- **举个例子**：系统每秒能处理1000个登录请求，TPS就是1000
- **计算方法**：总请求数 ÷ 测试时间（秒）
- **影响因素**：服务器CPU、内存、数据库性能

### 3. 并发用户数（Concurrent Users）
- **定义**：同时向系统发送请求的用户数量
- **注意**：不是在线用户数！在线用户可能只是打开页面没操作，并发用户是正在操作的用户
- **举个例子**：1000人在线，可能只有100人同时点击购买，并发用户数是100
- **计算方法**：并发用户数 = (TPS × 平均响应时间) ÷ 1000
- **影响因素**：系统的连接数限制、线程池大小

### 4. 资源利用率（Resource Utilization）
- **定义**：系统硬件资源的使用情况
- **具体指标**：
  - **CPU使用率**：CPU被占用的百分比
    - 正常范围：≤70%（超过80%可能有瓶颈）
    - 过高影响：处理速度变慢，响应时间增加
  - **内存使用率**：内存被占用的百分比
    - 正常范围：≤80%（持续增长可能内存泄漏）
    - 过高影响：频繁GC（垃圾回收），响应时间波动大
  - **磁盘I/O**：磁盘读写的速度和频率
    - 正常范围：读写速率≤磁盘最大容量的70%
    - 过高影响：文件操作慢，数据库查询延迟
  - **网络I/O**：网络传输的数据量
    - 正常范围：≤带宽的80%
    - 过高影响：网络拥堵，请求超时
  - **数据库连接数**：当前使用的数据库连接数量
    - 正常范围：≤连接池最大容量的80%
    - 过高影响：新请求无法获取连接，等待时间长

### 5. 错误率（Error Rate）
- **定义**：出错的请求数占总请求数的比例
- **计算方法**：错误请求数 ÷ 总请求数 × 100%
- **举个例子**：1000个请求中5个出错，错误率0.5%
- **正常范围**：≤0.1%（严格要求）或≤1%（一般要求）
- **影响因素**：系统稳定性、代码bug、资源不足

## 三、性能测试流程

### 1. 准备阶段
- **明确目标**：比如验证系统能支持1000并发用户，响应时间≤2秒
- **了解业务**：梳理核心业务流程（比如电商的浏览商品→加入购物车→下单→支付）
- **准备环境**：
  - 测试环境尽量和生产环境一致（硬件、软件、配置）
  - 准备测试数据（比如10万条商品数据，1万条用户数据）
- **测试数据选择**：
  - **数据量的选择**：
    - 基准测试：使用与生产环境相似的数据量，确保测试结果具有代表性
    - 高并发测试：数据量可以适当减小，但要覆盖各种数据类型和边界情况
    - 大数据测试：使用接近或超过生产环境的数据量，测试系统在大数据量下的性能
  - **数据大小的影响**：
    - 小数据：请求处理速度快，适合测试系统的最大吞吐量
    - 大数据：请求处理时间长，适合测试系统的内存使用和磁盘I/O性能
    - 混合数据：更接近真实场景，适合综合性能测试
  - **数据分布**：
    - 均匀分布：适合测试系统的平均性能
    - 倾斜分布：存在热点数据，适合测试系统在热点数据下的性能
    - 随机分布：模拟真实用户行为，适合综合性能测试
  - **数据类型**：
    - 覆盖各种数据类型（字符串、数字、日期、二进制等）
    - 包含边界值（最大值、最小值、空值等）
    - 包含真实业务场景数据
- **选择工具**：
  - 入门推荐：JMeter（免费、功能全、易上手）
  - 其他工具：Postman（API测试）、Locust（分布式测试）

### 2. 设计测试用例
- **选择测试场景**：
  - 单一场景：测试一个核心功能（比如登录）
  - 混合场景：模拟真实用户行为，包含多个功能（比如80%浏览，15%加入购物车，5%下单）
- **确定并发数**：
  - 从低到高：比如先10并发，再50，100，200...逐步增加
  - 持续时间：每个并发数运行5-10分钟

### 3. 执行测试
- **先跑冒烟测试**：用1个并发用户测试，确保脚本和环境没问题
- **逐步增加并发**：每次增加后观察5分钟，记录性能指标
- **监控资源**：实时查看CPU、内存、磁盘、网络等资源使用情况
- **记录数据**：保存所有性能指标数据，用于后续分析

### 4. 分析结果
- **看核心指标**：
  - 响应时间是否≤预期？
  - TPS是否达到目标？
  - 错误率是否≤阈值？
  - 资源利用率是否正常？
- **找瓶颈**：哪个资源先达到瓶颈（CPU？内存？数据库？）
- **出报告**：总结测试结果，列出问题和优化建议

## 四、内存溢出等问题的判断方法

### 1. 内存溢出（OOM - Out of Memory）
- **定义**：系统内存不足，无法分配新的内存空间
- **表现**：
  - 系统报错："Out of Memory"或"内存不足"
  - 响应时间突然变长，然后系统崩溃
  - 内存使用率持续增长，超过90%且不下降
  - 日志中出现OOM相关错误信息
- **判断方法**：
  - **监控内存使用率**：
    - 如果内存使用率持续上升，没有下降趋势，可能内存泄漏
    - 如果突然达到100%，系统崩溃，可能内存溢出
  - **查看GC日志**：
    - 频繁Full GC（垃圾回收），但内存释放很少
    - GC时间越来越长（比如从100ms增加到5秒）
  - **分析堆转储文件（Heap Dump）**：
    - 使用工具（如MAT、JProfiler）分析堆内存中的对象
    - 找出占用内存最多的对象，判断是否泄漏
- **常见原因**：
  - 内存泄漏：对象创建后没有被正确释放（比如静态集合持有对象引用）
  - 数据量过大：一次性加载过多数据到内存（比如查询100万条数据）
  - 内存配置不足：JVM堆内存设置太小

### 2. 线程泄漏（Thread Leak）
- **定义**：线程创建后没有被正确销毁，导致线程数持续增加
- **表现**：
  - 线程数持续增长，超过线程池最大值
  - CPU使用率高，因为大量线程竞争资源
  - 系统响应变慢，因为线程调度开销大
- **判断方法**：
  - 监控线程数：使用jstack或监控工具查看线程数量
  - 分析线程状态：大量线程处于WAITING或BLOCKED状态
  - 查看线程栈：找出线程创建的位置和原因

### 3. 数据库连接泄漏
- **定义**：数据库连接使用后没有关闭，导致连接数持续增加
- **表现**：
  - 数据库连接数达到最大值，无法创建新连接
  - 应用报错："Could not get JDBC Connection"
  - 数据库日志中出现连接超时错误
- **判断方法**：
  - 监控数据库连接数：使用数据库监控工具查看当前连接数
  - 查看连接池配置：连接池最大连接数是否合理
  - 检查代码：是否正确关闭Connection、Statement、ResultSet

### 4. 磁盘空间不足
- **表现**：
  - 系统报错："No space left on device"
  - 日志写入失败
  - 数据库无法写入数据
- **判断方法**：
  - 监控磁盘使用率：使用df命令查看磁盘空间
  - 检查日志文件大小：日志是否过大导致磁盘满
  - 清理临时文件：定期清理不需要的文件

## 五、不同场景的并发数建议

| 业务类型 | 日常并发 | 峰值并发 | 压力测试并发 |
|---------|---------|---------|-------------|
| 小型网站 | 10-100 | 100-500 | 500-1000 |
| 中型网站 | 100-500 | 500-2000 | 2000-5000 |
| 大型网站 | 500-2000 | 2000-10000 | 10000-50000 |
| API服务 | 1000-5000 RPS | 5000-20000 RPS | 20000-100000 RPS |

### 注意事项
- 并发数不是越大越好，要根据业务需求和系统能力确定
- 压力测试的并发数应超过预期峰值，找出系统极限
- 持续时间要足够长，至少5分钟，确保系统稳定

## 六、并发测试后的分析步骤

### 1. 整理数据
- 把测试过程中的所有指标数据整理成表格或图表
- 关注关键指标：响应时间（P50/P90/P95）、TPS、错误率、资源利用率

### 2. 分析趋势
- **TPS趋势**：随着并发数增加，TPS是否线性增长？如果出现平台期或下降，说明有瓶颈
- **响应时间趋势**：随着并发数增加，响应时间是否突然变长？
- **资源利用率趋势**：哪个资源先达到饱和？

### 3. 定位瓶颈
- **CPU瓶颈**：
  - 现象：CPU使用率>80%，响应时间增加，TPS下降
  - 原因：代码效率低、死循环、频繁GC
  - 解决：优化代码、调整GC策略
- **内存瓶颈**：
  - 现象：内存使用率>80%，频繁GC，响应时间波动大
  - 原因：内存泄漏、数据量过大
  - 解决：修复内存泄漏、增加内存配置
- **磁盘I/O瓶颈**：
  - 现象：磁盘读写速率>磁盘最大容量的80%，IOPS高
  - 原因：频繁读写文件、数据库查询慢
  - 解决：优化数据库查询、使用缓存、升级磁盘
- **网络瓶颈**：
  - 现象：网络吞吐量>带宽的80%，延迟高
  - 原因：数据传输量大、网络设备性能不足
  - 解决：压缩数据、升级网络设备
- **数据库瓶颈**：
  - 现象：数据库连接数满、查询响应时间长、锁等待时间长
  - 原因：SQL语句慢、索引缺失、连接池配置不合理
  - 解决：优化SQL、添加索引、调整连接池

### 4. 验证优化效果
- 修复瓶颈后，重新运行测试
- 对比优化前后的性能指标，确认问题是否解决
- 如果还有问题，继续分析和优化

## 七、性能测试工具入门

### 1. JMeter基本使用
- **下载安装**：从官网下载（https://jmeter.apache.org/），解压后运行bin/jmeter.bat
- **创建测试计划**：
  1. 右键"测试计划"→添加→线程（用户）→线程组
  2. 设置线程数（并发用户数）、 Ramp-Up时间（多少秒内启动所有线程）、循环次数
  3. 右键线程组→添加→Sampler→HTTP请求（或其他请求类型）
  4. 设置服务器名称、端口、路径、方法等
  5. 右键HTTP请求→添加→断言→响应断言（验证响应是否正确）
  6. 右键线程组→添加→监听器→查看结果树（查看请求和响应）
  7. 右键线程组→添加→监听器→聚合报告（查看TPS、响应时间等）
- **运行测试**：点击工具栏的"启动"按钮，查看结果

### 2. 监控工具
- **系统监控**：Windows任务管理器、Linux top命令
- **JVM监控**：jconsole、jvisualvm（JDK自带）
- **数据库监控**：MySQL Workbench、pgAdmin
- **APM工具**：SkyWalking、Pinpoint（分布式追踪）

## 八、快速上手步骤

### 第1步：明确测试目标
- 比如：验证登录功能在100并发下，响应时间≤2秒，错误率≤0.1%

### 第2步：准备测试数据
- 创建100个测试用户账号
- 确保测试环境数据库中有足够的数据

### 第3步：编写JMeter脚本
- 创建线程组：100线程，Ramp-Up时间10秒，循环10次
- 添加HTTP请求：登录接口，参数化用户名和密码
- 添加响应断言：验证登录成功
- 添加监听器：聚合报告、查看结果树

### 第4步：运行测试
- 启动JMeter，点击运行按钮
- 观察监听器中的结果

### 第5步：分析结果
- 查看聚合报告：
  - 平均响应时间：比如1500ms（符合≤2秒要求）
  - TPS：比如60（每秒处理60个登录请求）
  - 错误率：0%（符合≤0.1%要求）
- 查看资源利用率：
  - CPU使用率：50%（正常）
  - 内存使用率：60%（正常）

### 第6步：优化和迭代
- 如果有瓶颈，分析原因并优化
- 重新运行测试，验证优化效果

## 九、常见问题及解决方案

### 1. 测试结果不稳定
- **原因**：测试环境不稳定、外部干扰、脚本问题
- **解决**：
  - 确保测试环境隔离，关闭其他无关程序
  - 多次运行测试，取平均值
  - 优化脚本，添加思考时间（模拟用户操作间隔）

### 2. 脚本运行报错
- **原因**：参数错误、断言失败、网络问题
- **解决**：
  - 查看"查看结果树"中的响应，找出错误原因
  - 检查请求参数是否正确
  - 调整断言条件，确保符合实际响应

### 3. TPS上不去
- **原因**：存在性能瓶颈、测试工具限制
- **解决**：
  - 检查资源利用率，找出瓶颈
  - 增加测试机数量，使用分布式测试
  - 优化测试脚本，减少脚本本身的开销

### 4. 响应时间过长
- **原因**：网络延迟、服务器处理慢、数据库查询慢
- **解决**：
  - 优化网络环境，减少网络延迟
  - 优化代码，提高处理速度
  - 优化数据库查询，添加索引

## 十、性能测试最佳实践

1. **从基础开始**：先跑基准测试，建立性能基线
2. **逐步增加并发**：不要一开始就用最大并发，容易压垮系统
3. **监控全面**：不仅监控应用，还要监控系统、数据库、中间件
4. **模拟真实场景**：添加思考时间、参数化、关联（处理动态数据）
5. **关注用户体验**：重点看P90/P95/P99响应时间，不是平均响应时间
6. **记录详细**：保存所有测试数据和配置，便于后续对比
7. **持续测试**：在开发过程中定期进行性能测试，早发现问题
8. **结合业务**：性能测试要服务于业务需求，不是为了测试而测试

## 十一、总结

性能测试是一个系统性工程，需要了解业务、掌握工具、分析数据、定位瓶颈。通过本文的基础指南，你应该能够：
- 理解性能测试的核心参数
- 设计基本的性能测试场景
- 运行测试并分析结果
- 判断内存溢出等问题
- 定位和解决性能瓶颈

建议从简单的场景开始，逐步积累经验，不断优化测试方法。记住，性能测试的目标是确保系统在真实环境下能够稳定、高效地运行，提供良好的用户体验。