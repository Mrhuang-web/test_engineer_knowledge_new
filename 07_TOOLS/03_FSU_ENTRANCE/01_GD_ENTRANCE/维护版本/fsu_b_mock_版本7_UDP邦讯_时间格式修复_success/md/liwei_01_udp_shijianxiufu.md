错误根因
StringIndexOutOfBoundsException: begin 23, end 37, length 32
代码试图从第23位截取到第37位（共14个字符，对应7字节数据）
但实际接收到的字符串只有32个字符，缺少5个字符
这通常意味着数据包被截断（TCP粘包/半包或UDP分包）
4AF2E7 协议分析
你提供的 4AF2E7 是十六进制字节流，对应协议字段：
表格
复制
字节	值	协议含义	说明
第1字节	4A	CID2	读取信息命令 (0x4A)
第2字节	F2	COMMAND GROUP	读取命令分组 (0xF2)
第3字节	E7	COMMAND TYPE	远程监控/事件查询 (0xE7)
这说明代码试图解析的是一个事件读取/监控响应，但数据长度不足。
正确的事件数据组装
根据协议，完整的事件（历史记录）格式应为 14字节（28个十六进制字符）：
事件来源(5字节) + 日期时间(7字节) + 状态(1字节) + 备注(1字节) = 14字节
正确组装示例
如果 4AF2E7 是命令头，完整的事件响应数据应该是：
hex
复制
// 标准ACUC3.0协议帧（ASCII十六进制表示）
7E                    // SOI (7E)
10                    // VER (1.0)
01                    // ADR (设备地址01)
80                    // CID1 (门禁类80)
4A                    // CID2 (读取命令4A)
00 1C                 // L.TH (长度=14=0x1C，ASCII: 30303143？不对，需按协议计算LTH)
// 实际上 L.TH 是2字节，每字节拆成2个ASCII字符，共4字符

// 正确的完整帧结构（以读取事件响应为例）：
7E 31 30 30 31 38 30 34 41 30 30 31 43 [事件数据28字符] [校验和4字符] 0D

// 其中事件数据（14字节 = 28字符）示例：
// 卡号(5字节): 12 34 56 78 9A -> 31323334353637383941 (10字符)
// 时间(7字节): 20 26 01 31 11 44 00 -> 32303236303133313134343030 (14字符)  
// 状态(1字节): 01 -> 3031 (2字符)
// 备注(1字节): 00 -> 3030 (2字符)
关键问题
你的代码在第318行执行了：
java
复制
String eventData = message.substring(23, 37); // 取14个字符
但协议规定事件数据是 14字节 = 28个十六进制字符，而非14个字符。
可能的错误：
长度计算错误：代码按7字节(14字符)解析，但协议是14字节(28字符)
数据截断：设备或网络只传输了部分数据（32字符长度明显不足，正常应≥46字符）
修复建议
1. 立即修复（添加边界检查）
java
复制
// 在 CHD803LMStrategy.java:318 添加长度校验
if (message == null || message.length() < 46) { // 标准帧至少46字符
    log.error("事件数据长度不足，期望≥46，实际{}，原始数据：{}", 
              message != null ? message.length() : 0, message);
    return null; // 或抛出业务异常
}

// 如果确认是7字节简化格式，则检查37
if (message.length() < 37) {
    log.warn("数据截断，可能粘包/半包，当前长度{}，缓存等待下一包", message.length());
    // 实现粘包处理逻辑：缓存当前数据，等待后续数据拼接
    return null;
}
2. 协议对齐确认
核对设备实际发送的格式：
标准ACUC3.0协议：事件数据14字节 → 28个十六进制字符，总帧长≥46
力维UDP简化协议：可能去掉了部分头部，但事件数据仍应保持14字节完整
如果设备确实只发送了7字节事件数据（不符合协议），需要：
修改设备固件配置，启用完整事件格式
或修改代码适配7字节格式（需确认字段截取逻辑）
3. 粘包/分包处理
由于长度32接近37（差5），极可能是TCP粘包导致数据被分割。建议在 DecodeMessageListener 实现缓存机制：
java
复制
// 伪代码：处理半包
private String buffer = "";

public void listen(String message) {
    buffer += message;
    while (buffer.length() >= 46) { // 假设46是标准帧最小长度
        String frame = extractFrame(buffer); // 按SOI(7E)/EOI(0D)提取完整帧
        handleEvent(frame);
        buffer = remainingBuffer();
    }
}
总结
4AF2E7 是读取命令头（CID2=4A + GROUP=F2 + TYPE=E7），但后续缺少了14字节的事件数据（28个十六进制字符）。
正确组装要求：确保事件数据包含完整的 5字节卡号 + 7字节时间 + 1字节状态 + 1字节备注（共14字节，28字符），整个协议帧长度应 ≥46个字符（含头部和校验）。