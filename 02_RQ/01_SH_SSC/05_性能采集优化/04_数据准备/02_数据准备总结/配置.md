# 前置说明：

```
1. 找到配置文件
    在 JMeter 安装目录下定位：
    {JMeter安装路径}/bin/jmeter.properties
2. 编辑配置项
    用文本编辑器打开 jmeter.properties，搜索并修改以下参数（如果不存在则添加）：

    # 增加JMeter线程池容量（取消注释并修改）
    jmeter.threadgroup.max_thread_num=1000

    # 缩短统计间隔（取消注释并修改）
    summariser.interval=10
    注意：如果找不到这两项，直接在文件末尾追加即可。
3. 生效配置
    方式一：重启JMeter GUI
    保存文件后，完全关闭JMeter
    重新启动JMeter
```



### 1 安装必备插件

Plugins Manager 里一次性勾选安装：

- Custom Thread Groups（含 Concurrency Thread Group、Throughput Shaping Timer）
- PerfMon (Servers Performance Monitoring) – 可选，方便同时看服务器资源

------

### 2 换线程组：Concurrency Thread Group

1. 测试计划 → 右键 → Add → Threads → **Concurrency Thread Group**
2. 参数填：
   - Target Concurrency: **80**（先给富余量，后面会动态掉）
   - Ramp-Up Time (min): **0**（立即起压）
   - Ramp-Up Steps: **0**
   - Hold Target Rate Time (min): **10080** = 7 天 × 24 h × 60 min
   - Time Unit: **Minutes**
     这样脚本会连续跑 **整整一周** 不停。

------

### 3 加限流器：Throughput Shaping Timer

1. 同级 → Add → Timer → **Throughput Shaping Timer**

2. 点 “Add row” 两次，画一条直线：

   

   复制

   ```
   Start RPS | End RPS | Duration (sec)
   ------------------------------------
        50   |    50   |  604800   ← 7 天换算成秒
   ```

   

3. 关键：把最后一列 **Initial/Startup delay 留空**，让压测 **立即开始** 50 TPS。

4. 勾上底部的 **“Schedule Feedback Function”**，会自动弹出函数：

   ```
   ${__tstFeedback(throughputShapingTimer,1,100,10)}
   ```

   

   把它复制到 Concurrency Thread Group 的 **“Target Concurrency” 字段**，代替刚才手写的 80。
   含义：JMeter 实时计算 **需要多少线程才能打到 50 TPS**，1~100 之间自动补位，每 10 秒校正一次。

------

### 4 保证“无限”循环

Concurrency Thread Group 已经按 **时间** 控制生命周期，所以下边的 HTTP Sampler

- 循环次数 **必须选 “Infinite”**（默认就是），
- 否则线程跑完固定次数就提前退出，会导致 TPS 掉底。

------

### 5 输出与监控

1. 聚合报告 / Backend Listener → 把数据实时打到 **InfluxDB**，配合 **Grafana** 做大屏，7 天曲线一目了然。
   - Backend Listener 配置：
     - influxdbUrl: `http://your_influx:8086/write?db=jmeter`
     - application: `50tps_week`
2. 关键指标一定看：
   - 实际 TPS（grafana 里对应 `jmeter.all.a.count`）
   - P95 / P99 响应时间
   - 错误率 > 0 就短信/邮件告警
3. 本地磁盘也要留一份结果：
   - 测试计划 → 非 GUI 命令加 `-l week50tps.jtl`，防止 Influx 挂掉数据全丢。

------

### 6 非 GUI 启动 & 7 天守护

Windows / Linux 同样适用：

bash

复制

```bash
# 先cd到JMeter目录
nohup ./bin/jmeter -n -t week50tps.jmx -l week50tps.jtl \
  -j week50tps.log > /dev/null 2>&1 &
```

- `-n` 非 GUI，省内存；
- `nohup` + `&` 让进程常驻，SSH 断开也继续跑；
- 日志 `-j` 单独文件，方便 `tail -f` 看有没有 OOM 或断开。

------

### 7 常见坑提前提醒

表格

复制

| 坑点                            | 解法                                                         |
| :------------------------------ | :----------------------------------------------------------- |
| 1. 本机端口耗尽 / TCP TIME_WAIT | ① 压测机加多网卡 IP，② 改 `server.rmi.localport` 范围，③ 开 `tcp_tw_reuse` |
| 2. JMeter 内存撑爆              | 改 `bin/jmeter` 文件里 `HEAP="-Xms4g -Xmx4g"`（看机器内存给 4~8 G） |
| 3. 日志把磁盘打满               | ① log4j2.xml 把 `org.apache.http` 级别调到 `error`；② 用 `logrotate` 每天切分 |
| 4. 后端变慢 → TPS 掉底          | Throughput Shaping Timer 会拼命加线程，**上限 100** 如果还不够，手动把 `__tstFeedback` 第三个参数再加大 |
| 5. 网络闪断/重启                | 用 `screen` 或 `tmux` 代替 `nohup`，可断点续看；或者直接放 CI 机器 / 容器里跑 |

------

### ✅ 一句话回顾

> **Concurrency Thread Group 管“跑多久”，Throughput Shaping Timer 管“每秒 50 请求”，__tstFeedback 让线程数自己涨落，非 GUI + nohup 跑 7 天，Influx+Grafana 做实时监控，**—— 按上面 6 步配完就能安心让机器自己压一周，回来收报告即可。















### ✅ 正确完整配置（对照截图改）

#### 1. Concurrency Thread Group（你截图这部分）

**把 Target Concurrency 的 `80` 换成下面这个函数**：

```
${__tstFeedback(throughputShapingTimer,1,100,10)}
```

- 作用：让 JMeter **自动计算**需要多少线程才能打出 50 TPS，在 1~100 之间动态调整，每 10 秒校正一次。

其他保持你截图的设置：

- Ramp Up Time: `0` ✓
- Hold Target Rate Time: `10080` ✓（7 天）
- 错误后动作: **继续** ✓

------

#### 2. Throughput Shaping Timer（必须新建）

在线程组上右键 → Add → Timer → **Throughput Shaping Timer**
按下图填：

表格

复制

| Start RPS | End RPS | Duration, sec |
| :-------- | :------ | :------------ |
| 50        | 50      | **604800**    |

- **Duration 604800 = 7 天 × 24 小时 × 3600 秒**，跟你上面的 10080 分钟对上。
- 底部勾选 **"Schedule Feedback Function"** → 才会自动生成前面那个 `__tstFeedback` 函数。

------

### ✅ 配置完以后的样子



复制

```
测试计划
└─ bzm - Concurrency Thread Group
   ├─ Target Concurrency: ${__tstFeedback(throughputShapingTimer,1,100,10)}  ← 函数
   ├─ Hold Target Rate Time: 10080 minutes
   └─ jp@gc - Throughput Shaping Timer  ← 限流器
        └─ 50 rps for 604800 seconds
   └─ HTTP 请求...（你的接口）
```

------

### ⚠️ 一句话检查

> **没加 Throughput Shaping Timer → 不可能稳定 50 TPS。**
> **不加 __tstFeedback 函数 → 线程数不会自动涨，后端变慢就掉 TPS。**
> 补上这两点，你的截图配置就完美了。













**你的版本较老，确实没有自动勾选框。**
没关系，咱们**手动填**就行，效果完全一样。

------

### ✅ 手动填 Feedback 函数

1. **在 Concurrency Thread Group 里**
   把 `Target Concurrency` 的 `80` 改成下面这串（**直接复制粘贴**）：

   ```
   ${__tstFeedback(你的定时器名称,1,100,10)}
   ```

   

2. **把 `你的定时器名称` 替换成**
   你那个 Throughput Shaping Timer 的 **Name** 字段的值。
   比如你的截图里 Name 是 `jp@gc - Throughput Shaping Timer`，那就写：

   ```
   ${__tstFeedback(jp@gc - Throughput Shaping Timer,1,100,10)}
   ```

   

   **注意**：名称必须 **一字不差**，包括空格、大小写。

------

### 参数是什么意思？

```
${__tstFeedback(定时器名, 起始线程数, 最大线程数, 检查间隔秒)}
```

- **起始线程数**：`1` → 最低保留 1 个线程
- **最大线程数**：`100` → 最多涨到 100 个（如果后端变慢，TPS 要维持 50，就得加线程）
- **检查间隔**：`10` → 每 10 秒算一次需要多少线程

------

### 一句话总结

> 老版本没有自动勾选 → **手动把那段函数粘到 Target Concurrency**，把里面的定时器名字改成你自己的，完事儿。