# 维谛

## 前置

```
1byte = 8bit
即1个字符1字节
	1字符（即任意的数字或字母）
	1个字节8bit（由01组成 ->  00000001）

需要之前fsu-sc：透传协议
地址：就是
	据帧/报文里每个字节的偏移量（index）
	从 0 开始计数，可以理解为“第几个字节”
	0 → 第 1 个字节
	1-20 → 第 2~21 个字节（共 20 字节）
	
[32 字节数据（末尾 0D B7 在内)]  [1 字节异或校验]  [FE]





先把“子帧”和“主帧”完全拆开，就一眼看懂 0D、B7 各是干啥：
子帧（485 层）
	为了让收端能判断自己的数据有没有错，它按常规 485 做法在末尾放了 2 B 的 CRC16：
	低字节在前 → 0D
	高字节在后 → B7
	这两字节只负责子帧本身的完整性，跟外层主帧毫无关系。
主帧（UDP/网络层）
	它把整个子帧（含那 2 B CRC16）当成普通 payload 打包，并在自己的协议尾再加 1 B 异或校验（P_verify）——这 1 B 是对前面 32 B 整体（含 0D B7）做异或得出的结果，放在第 33 字节；第 34 字节放 0xFE 包尾。
所以：
	0D + B7 → 子帧级 CRC16，仅保证子帧数据正确；
	后面再跟的 1 B → 主帧级异或校验，保证整包在链路上没出错。
	两者作用不同、层级不同、长度也不同，互不冲突。





【主帧头】
FF
【20 B FSUID】
31 32 34 31 32 33 31 33 31 32 34 31 00 00 00 00 00 00 00 00
【12 B 附加字段 → 29~35 字节】
01 20 25 00 EE 01
【2 B 长度字段 → 36~37 字节】
00 20
【32 B 透传数据（子帧）→ 38~(38+31) 字节】
00 7E 31 30 30 31 38 30 34 38 32 30 30 45 46 30 45 30 30 30 30 30 30 30 30 30 30 46 41 43 38
【1 B 主帧异或校验 P_verify → 38+32=70 字节】
B7
【1 B 主帧包尾 → 71 字节】
FE


偏移 70（十进制第 70 字节，从 0 起算）那一 byte 就是 B7——它正是对前面 32 B 透传数据做 单字节异或 的结果。
所以你写的 0DB7 FE 里：
0D 属于子帧 CRC 的低字节（算在 32 B 数据内）
B7 既是子帧 CRC 高字节，也是主帧的 1 B 异或校验（协议规定异或范围刚好包含它）
FE 是主帧包尾

不是“没有校验位”，B7 就是主帧的 1 字节异或校验（P_verify），只是它恰好也被子帧当 CRC 高字节用而已



计算校验
	先把“待校验区域”一次性切出来（包头 0xFF 和包尾 0xFE 不算）：
        31 32 34 31 32 33 31 33 31 32 34 31 00 00 00 00 00 00 00 00   ; 20 B FSUID
    01 20 25 00 EE 01                                           ; 6 B 控制字段
    00 20                                                       ; 2 B 长度
    00 7E 31 30 30 31 38 30 34 38 32 30 30 45 46 30 45 30 30 30 30 30 30 30 30 30 30 46 41 43 38  ; 32 B 透传数据
    共 20 + 6 + 2 + 32 = 60 字节
    
    按字节依次异或（初始值 0x00）
        0x31⊕0x32⊕0x34⊕0x31⊕0x32⊕0x33⊕0x31⊕0x33⊕0x31⊕0x32⊕0x34⊕0x31
    ⊕0x00⊕0x00⊕0x00⊕0x00⊕0x00⊕0x00⊕0x00⊕0x00
    ⊕0x01⊕0x20⊕0x25⊕0x00⊕0xEE⊕0x01
    ⊕0x00⊕0x20
    ⊕0x00⊕0x7E⊕0x31⊕0x30⊕0x30⊕0x31⊕0x38⊕0x30⊕0x34⊕0x38⊕0x32⊕0x30⊕0x30
    ⊕0x45⊕0x46⊕0x30⊕0x45⊕0x30⊕0x30⊕0x30⊕0x30⊕0x30⊕0x30⊕0x30⊕0x30⊕0x30⊕0x30⊕0x46⊕0x41⊕0x43⊕0x38
    = 0xB7
    
    计算结果：0xB7（十进制 183）
    因此这条报文里
    P_verify 正确值就是 0xB7——与你抓到的字节完全一致，校验通过。
```

### A2透传协议

#### A 2.1 透传串口数据

**命令号：**0x0001

**命令描述：**该命令用于透传串口数据包，分为上行（FSU=>SC）和下行（SC =>FSU）两个方向；

**命令数据：**具体透传串口数据包格式按数据流方向分别定义如下：

l 下行方向（SC =>FSU）

| 地址        | 协议字段      | 字段长度 | 字段描述                                                     | 默认值           |
| :---------- | ------------- | -------- | ------------------------------------------------------------ | ---------------- |
| 0           | P_header      | 1 byte   | 协议包的开始标识ff                                           | 0xFF             |
| 1-20        | P_dest_addr   | 20bytes  | 目标设备地址                                                 | FSU的ID          |
| 21-28       | P_src_addr    | 8byte    | 源设备地址                                                   | SC的地址取值为00 |
| 29          | P_subDevType  | 1 byte   | 子设备类型：1：串口设备2：USB设备3：IP网络设备               | 1                |
| 30          | P_subDev_addr | 1 byte   | 透传模块：Bit0~4:串口号；Bit5~8： 表示虚拟设备号（即串口总线模式下的地址号）；当子设备类型为USB/IP时，此字段为00。 |                  |
| 31-32       | P_pLen        | 2 byte   | 协议族数据包长度                                             | 5+N              |
| 33          | RtnFlag       | 1byte    | 设置/应答类型                                                | 0xee             |
| 34-35       | CommType      | 2 bytes  | 命令编号<br />CommType 的低字节（高字节 00 省略没贴）<br />日志过滤了00，但真是请求不可以漏 | 0x0001           |
| 36-37       | 透传数据长度  | 2 byte   | 透传数据长度                                                 |                  |
| 38-(38+N-1) | 透传数据      | N byte   | 数据内容                                                     |                  |
| 38+N        | P_verify      | 1 byte   | 协议包的校验字段，采用异或校验，在数据转义之前，对协议数据计算校验值，计算时不包含包头和包尾 |                  |
| 39+N        | P_tailer      | 1 byte   | 协议包的结束标识fe                                           | 0xFE             |

 

l 上行方向（FSU=>SC）

| 地址        | 协议字段      | 字段长度 | 字段描述                                                     | 默认值             |
| ----------- | ------------- | -------- | ------------------------------------------------------------ | ------------------ |
| 0           | P_header      | 1 byte   | 协议包的开始标识ff                                           | 0xFF               |
| 1-8         | P_dest_addr   | 8bytes   | 目标设备地址                                                 | SC的地址取值为0x00 |
| 9-28        | P_src_addr    | 20byte   | 源设备地址                                                   | FSU的ID            |
| 29          | P_subDevType  | 1 byte   | 子设备类型：1：串口设备2：USB设备3：IP网络设备               | 1                  |
| 30          | P_subDev_addr | 1 byte   | 透传模块：Bit0~4:串口号；Bit5~8： 表示虚拟设备号（即串口总线模式下的地址号）；透传模块：Bit0~4:串口号；Bit5~8： 表示虚拟设备号（即串口总线模式下的地址号）；当子设备类型为USB/IP时，此字段为00。 |                    |
| 31-32       | P_pLen        | 2 byte   | 协议族数据包长度                                             | 5+N                |
| 33          | RtnFlag       | 1byte    | 设置/应答类型                                                | 0x00               |
| 34-35       | CommType      | 2 bytes  | 命令编号                                                     | 0x0001             |
| 36-37       | 透传数据长度  | 2 byte   | 透传数据长度                                                 |                    |
| 38-(38+N-1) | 透传数据      | N byte   | 数据内容                                                     |                    |
| 38+N        | P_verify      | 1 byte   | 协议包的校验字段，采用异或校验，在数据转义之前，对协议数据计算校验值，计算时不包含包头和包尾 |                    |
| 39+N        | P_tailer      | 1 byte   | 协议包的结束标识fe                                           | 0xFE               |

 

#### A 2.2FSU透传通道接口

  命令号：0x0002

命令描述：FSU定时（例如：每隔120秒） 向SC发送一个心跳包数据，SC根据接收心跳消息的情况进行链路连接状态的判断。当SC在360秒内未收到任何心跳消息时，则认为SC和FSU之间的透传通道中断。

命令数据：（方向：FSU => SC）

| 地址  | 协议字段      | 字段长度 | 字段描述                                                     | 默认值         |
| ----- | ------------- | -------- | ------------------------------------------------------------ | -------------- |
| 0     | P_header      | 1 byte   | 协议包的开始标识ff                                           | 0xFF           |
| 1-8   | P_addr        | 8bytes   | 目标设备地址                                                 | SC的地址为0x00 |
| 9-28  | P_src_addr    | 20bytes  | 源设备地址                                                   | FSU的ID        |
| 29    | P_subDevType  | 1 byte   | 子设备类型：1：串口设备2：USB设备3：IP网络设备               | 1              |
| 30    | P_subDev_addr | 1 byte   | 透传模块：Bit0~4:串口号；Bit5~8： 表示虚拟设备号（即串口总线模式下的地址号）；当子设备类型为USB/IP时，此字段为00。 |                |
| 31-32 | P_pLen        | 2 byte   | 协议族数据包长度                                             | 3              |
| 33    | RtnFlag       | 1byte    |                                                              | 0xED           |
| 34-35 | CommandType   | 2 byte   | 命令号                                                       | 0x0002         |
| 36    | P_verify      | 1 byte   | 协议包的校验字段，采用异或校验，在数据转义之前，对协议数据计算校验值，计算时不包含包头和包尾 |                |
| 37    | P_tailer      | 1 byte   | 协议包的结束标识fe                                           | 0xFE           |

#### A 3转义字段

如第2节所述，每个协议的包头、包尾分别固化取值为0xFF和0xFE，当协议包头和包尾之间的数据出现0xFF、0xFE或0xFD时，需要转义，转义规则如下：

0xFF： 0xFD 0x00

0xFE： 0xFD 0x01

0xFD： 0xFD 0x02

在FSU与SC之间的透传接口传输的上下行数据都需要转义，实际传输的内容是转义后的数据。







## 通信规范

```
大概作用：
	就是su与es2000，es2000与su之前发送请求和接收应答时，传输格式的要求
```



### 数据包格式

```
协议转换方向（动环←→ES2000）
	总线角色
		SU（上位机、局站控制单元）= 主站 = 你写的程序
		ES2000（门控器）= 从站 = 被查询/被设置的那一方
	区分
		SU→ES2000 叫“命令帧”
		ES2000→你 叫“应答帧”
	帧里唯一会变方向的字段
		CID2/RTN 这一个字节：
		命令帧里它叫 CID2（表示你要干什么，比如读门状态、写卡号）
		应答帧里它叫 RTN（表示从站执行结果，00H=成功，其他=异常码）
```



| 字段     | 长度 | 说明                                          |
| -------- | ---- | --------------------------------------------- |
| SOI      | 1 B  | 固定 7EH                                      |
| VER      | 1 B  | 固定 10H（协议 V1.0）                         |
| ADR      | 1 B  | 从站地址 1-254（拨码决定）                    |
| CID1     | 1 B  | 固定 80H（环境控制类+组0）                    |
| CID2/RTN | 1 B  | 命令时=CID2，应答时=RTN                       |
| LCHKSUM  | 1 B  | 本帧“INFO 区”长度低 8 位                      |
| L        | 1 B  | 本帧“INFO 区”长度高 8 位                      |
| INFO     | n B  | 命令帧=COMINFO；应答帧=DATAINFO               |
| CHKSUM   | 2 B  | 从 VER 到 INFO 最后一个字节累加和，高字节在前 |
| EOI      | 1 B  | 固定 0DH                                      |

CID1

```
1 bit 只有 0/1 两种状态。
1 byte=8 bit 才有 2⁸=256 种状态（0x00~0xFF）
4bit 能表示 16 个组 是 2⁴=16
	4 位二进制：0000₂~1111₂ 正好 16 种组合，对应组号 0~15
组内地址格式是 0x01–0xFE
	0x00 常被协议留作“广播地址”，0xFF 常被留作“全局广播/无效”
	于是可用范围只剩 0x01~0xFE（1~254）。
	这是协议硬性规定，就像 IP 里 0 和 255 也不能随意分给主机一样
1000 0000₂ → 0x80 → 80H
	把二进制 4 位一组：
	1000 0000 → 1000₂=8，0000₂=0 → 十六进制 80。
	在汇编/调试器里习惯在数字后面加 H（Hex），所以写成 80H，意思跟 0x80 完全一样
“80H”只是“环境控制类（8）+第0组”的简写；
	真正让系统突破 254 台限制的，是再用第二字节给每组分 254 个地址，
	于是 16 组 × 254 台 = 4064 台设备	
0x01–0xFE 就是 十六进制（hex）




CID1说明：
	当系统里设备太多、一个字节（8bit）的地址不够用用『分类+分组』两个字段拼出一个新的1字节地址
	让系统最多能挂16×254台设备
	
	CID1是一个字节（8bit，D7…D0，D7是最高位）。
	把这8bit再劈成两半：
		高4bit（D7—D4）叫“设备分类码”。
		低4bit（D3—D0）叫“设备分组号”。
	分类码里，规定“环境控制类”=8，即二进制1000，对应D7=1、D6=D5=D4=0。
	分组号0–15，也就是4bit能表示的16个组。
	这样拼出来的一字节地址，高4位是分类、低4位是组号。
	同一组里再用另一个字节（0x01–0xFE，共254个）给每台设备编“组内地址”。
	于是理论上限：16组 × 254台 = 4064台设备。
	但ES2000目前把“分组号”固定成0，于是低4bit全是0；高4bit按环境控制类=8，即1000 0000₂ = 0x80。
		所以CID1永远写成80H，这就是你看到“CID1=80H”的来历
		
	“80H”就是“环境控制类+第0组”的缩写，先靠它把设备分到16个大组，再在组内用另一个字节给每台设备编号
		从而突破单字节254的地址上限
		
	协议说明：
		规定了高4bit必须为设备分类码，低4bit为分组码（目前分组为0，所以低4为只能为0000）
		其中 D7—D4 为设备分类码，环境控制类=8，即 D7=1，D6=D5=D4=0；
		而 D3—D0 为设备分组号（0—15）。
```

ARD

```
为“设备地址”或“设备 ID”
	device_code?
```

























## 校验

```
校验和验算
	参与区域：VER + ADR + CID1 + CID2 + LCHKSUM + L + INFO 全部字节
	算法：单字节循环累加，溢出不管，最后得到 16 位值（实际只低 16 位有效）
	填充顺序：高 8 位先放，低 8 位后放
```



## 读门状态

```
目标：让地址为 05H 的 ES2000 把当前门状态吐回来
假设“读门状态”这条命令的 CID2=30H，并且不需要额外参数（INFO 为空）

先填固定部分
	VER=10H, ADR=05H, CID1=80H, CID2=30H
	INFO 长度=0 → L=00H, LCHKSUM=00H
计算校验和
	累加字节序列：[10H,05H,80H,30H,00H,00H]
	和 = 10+05+80+30+00+00 = 0C5H
	高字节=00H，低字节=C5H
拼装完整命令帧（十六进制串）
	7E 10 05 80 30 00 00 00 C5 0D
	↑-----------------------↑
	SOI                     EOI
串口下发
	波特率 9600/19200（事先统一），8E1 或 8N1 按说明书配，把上面 10 个字节原样丢进去即可。
```





## 协议包字节拆解

```
除了 SOI(7EH)、EOI(0DH) 按原始字节发
	其余所有字节都要拆成 2 个 ASCII 发（高 4 位→ASCII，低 4 位→ASCII）
	校验和也要把“已转成 ASCII 后的所有字符”再按双字节累加、取补

```



| 字段     | 原始长度 | 在线路上实际长 | 发送方式                         |
| -------- | -------- | -------------- | -------------------------------- |
| SOI      | 1 B      | 1 B            | 原始 7EH                         |
| VER      | 1 B      | 2 B            | 先高 4 位 ASCII，再低 4 位 ASCII |
| ADR      | 1 B      | 2 B            | 同上                             |
| CID1     | 1 B      | 2 B            | 同上                             |
| CID2/RTN | 1 B      | 2 B            | 同上                             |
| LCHKSUM  | 1 B      | 2 B            | 同上                             |
| L        | 1 B      | 2 B            | 同上                             |
| INFO     | n B      | 2n B           | 每字节拆 2 ASCII                 |
| SUM      | 2 B      | 4 B            | 高 8 位→2 ASCII，低 8 位→2 ASCII |
| EOI      | 1 B      | 1 B            | 原始 0DH                         |



## 拆解后校验

```
LCHKSUM（4 位校验）
	原始 INFO 长度=L，则 LENID=2L（ASCII 位数）。
	把 LENID 看成 12 位二进制，按 4 位一组分成 3 个十六进制数字（0xX3,X2,X1）。
	LCHKSUM = ((~(X3+X2+X1) +1) & 0xF)。
	白话：
		把 3 个 4 位数相加，取低 4 位，再取反加 1（4 位补码）
		得到 4 位结果，拼成 1 字节发成 2 ASCII
		
SUM（双字节校验）
	范围：从 VER 的第一个 ASCII 字符开始，到 INFO 最后一个 ASCII 字符结束。
	把这些 ASCII 码（注意：是 ASCII 值，不是原始十六进制）两两拼成 16 位数循环累加，最后
	SUM16 = 0x10000 – (累加和 & 0xFFFF)
	高 8 位、低 8 位各自再拆成 2 个 ASCII 发送。
```



## 读门状态

```
再发一次“读门状态”命令（无参数）
已知：
	从站地址 adr=0x05
	CID2（命令码）=0x30
	INFO 长度 L=0 → LENID=0 → X3,X2,X1=0,0,0 → LCHKSUM=0
步骤：
	原始字节序列（不含 SOI/EOI/SUM）
		[VER,ADR,CID1,CID2,LCHKSUM,L] = [0x10,0x05,0x80,0x30,0x00,0x00]
	拆 ASCII
		10 → “31 30”
		05 → “30 35”
        80 → “38 30”
        30 → “33 30”
        00 → “30 30”
        00 → “30 30”
        拼成 ASCII 区：
        31 30 30 35 38 30 33 30 30 30 30 30
	算 SUM
        累加和 = 0x31+0x30+0x30+0x35+0x38+0x30+0x33+0x30+0x30+0x30+0x30+0x30
        = 0x0245
        SUM16 = 0x10000 – 0x0245 = 0xFDBB
        高→”46 44″，低→”42 42″
	最终线路字节流（十六进制）
		7E 31 30 30 35 38 30 33 30 30 30 30 30 46 44 42 42 0D
```























## 案例

```
1、access_control_device
	INSERT INTO `access_control_device` (`id`, `device_id`, `device_status`, `door_status`, `room_id`, `parent_id`, `device_name`, `device_type`, `access_mode`, `group_no`, `com_port`, `ip_address`, `port`, `protocol_version`, `protocol_start`, `protocol_end`, `controller_name`, `door_name`, `time`, `flag`, `device_code`, `partition`) VALUES (3105, '539ffc01-85b1-45dd-9e28-fbdcc621412e', 1, NULL, '01-01-10-02-01-03', NULL, '测试1', 1, NULL, '32', '01', '10.12.5.142', '8000', '10', '7E', '0D', '测试1', NULL, '2025-12-27', NULL, 'TEST', NULL);

2、协议 - 维谛

3、刷新连接操作
```



```
日志


---------------------------------------------------------------entrance-----------------------------------------------------------------------------


Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3000aefe] was not registered for synchronization because synchronization is not active
JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@3903033d] will not be managed by Spring
==>  Preparing: select * from access_control_device where device_id = ?
==> Parameters: 227f67f0-ac8a-44be-9910-36d9f20aef38(String)
<==    Columns: id, device_id, device_status, door_status, room_id, parent_id, device_name, device_type, access_mode, group_no, com_port, ip_address, port, protocol_version, protocol_start, protocol_end, controller_name, door_name, time, flag, device_code, partition
<==        Row: 3099, 227f67f0-ac8a-44be-9910-36d9f20aef38, 0, 0, 01-01-17-09-01-05, null, ???, 2, 2, 32, 01, 10.12.5.142, 10020, 10, 7E, 0D, ??1, ???, 2025-12-27, null, TEST, 188.22.57.143
<==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3000aefe]



Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4a386aea] was not registered for synchronization because synchronization is not active
JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@3903033d] will not be managed by Spring
==>  Preparing: select * from access_control_device where device_id = ?
==> Parameters: 227f67f0-ac8a-44be-9910-36d9f20aef38(String)
<==    Columns: id, device_id, device_status, door_status, room_id, parent_id, device_name, device_type, access_mode, group_no, com_port, ip_address, port, protocol_version, protocol_start, protocol_end, controller_name, door_name, time, flag, device_code, partition
<==        Row: 3099, 227f67f0-ac8a-44be-9910-36d9f20aef38, 0, 0, 01-01-17-09-01-05, null, ???, 2, 2, 32, 01, 10.12.5.142, 10020, 10, 7E, 0D, ??1, ???, 2025-12-27, null, TEST, 188.22.57.143
<==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4a386aea]


Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@76276326] was not registered for synchronization because synchronization is not active
JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@3903033d] will not be managed by Spring
==>  Preparing: select device_code from t_cfg_device where device_id in (select device_id from t_cfg_fsu where address = ?) limit 1
==> Parameters: 10.12.5.142(String)
<==    Columns: device_code
<==        Row: 124123131241
<==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@76276326]



Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4e7241e5] was not registered for synchronization because synchronization is not active
JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@3903033d] will not be managed by Spring
==>  Preparing: select device_status from access_control_device where device_id = ?;
==> Parameters: 227f67f0-ac8a-44be-9910-36d9f20aef38(String)
<==    Columns: device_status
<==        Row: 0
<==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4e7241e5]



Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6207d767] was not registered for synchronization because synchronization is not active
JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@3903033d] will not be managed by Spring
==>  Preparing: select door_status from access_control_device where device_id = ?;
==> Parameters: 227f67f0-ac8a-44be-9910-36d9f20aef38(String)
<==    Columns: door_status
<==        Row: 0
<==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6207d767]








2026-01-04 15:00:24.343  INFO 6 --- [ecode-Message-3] c.a.m.e.server.handler.ResponseHandler   : 获取到响应{"ip":"10.12.5.142","port":10020,"request":"{\"fsuId\":\"124123131241\",\"taskId\":\"0d506f93-2934-460d-a781-e39d9530bdd0\",\"protocolType\":\"lwUdp\",\"ip\":\"10.12.5.142\",\"port\":10020,\"deviceId\":\"227f67f0-ac8a-44be-9910-36d9f20aef38\",\"protocolCommon\":{\"commAdr\":\"01\",\"ver\":\"10\",\"soi\":\"7E\",\"eoi\":\"0D\"},\"commands\":{\"loginCmd\":{\"cid1\":\"80\",\"cid2\":\"48\",\"comd_group\":\"F0\",\"comd_type\":\"E0\",\"dataf\":\"0000000000\"},\"executeCmd\":{\"cid1\":\"80\",\"cid2\":\"4A\",\"comd_group\":\"F2\",\"comd_type\":\"E0\",\"dataf\":\"00\"}},\"requestType\":null,\"comPort\":32,\"methodType\":null,\"partition\":\"188.22.57.143\",\"cardNo\":null,\"requestCommand\":\"FF3132343132333133313234310000000000000000000000000000000001201D00EE010018007E313030313830344141303036463245303030464333440DC2FE\"}","response":"device get response overtime","taskId":"0d506f93-2934-460d-a781-e39d9530bdd0","deviceId":"227f67f0-ac8a-44be-9910-36d9f20aef38","status":"500","connectType":null,"requestType":null,"requestBody":null,"sdkType":null,"cardNo":null}，开始处理
Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@406d795e] was not registered for synchronization because synchronization is not active
JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@3903033d] will not be managed by Spring
==>  Preparing: select * from access_control_device where device_id = ?
==> Parameters: 227f67f0-ac8a-44be-9910-36d9f20aef38(String)
<==    Columns: id, device_id, device_status, door_status, room_id, parent_id, device_name, device_type, access_mode, group_no, com_port, ip_address, port, protocol_version, protocol_start, protocol_end, controller_name, door_name, time, flag, device_code, partition
<==        Row: 3099, 227f67f0-ac8a-44be-9910-36d9f20aef38, 0, 0, 01-01-17-09-01-05, null, ???, 2, 2, 32, 01, 10.12.5.142, 10020, 10, 7E, 0D, ??1, ???, 2025-12-27, null, TEST, 188.22.57.143
<==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@406d795e]
Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4a95122e] was not registered for synchronization because synchronization is not active
JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@3903033d] will not be managed by Spring
==>  Preparing: update access_control_device set device_status = ? where ip_address = ? and port = ?
==> Parameters: 0(Integer), 10.12.5.142(String), 10020(String)
<==    Updates: 3
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4a95122e]
2026-01-04 15:00:24.359  INFO 6 --- [ntainer#3-1-C-1] c.a.m.e.s.listener.BizMessageListener    : 设备227f67f0-ac8a-44be-9910-36d9f20aef38更新操作记录














---------------------------------------------------------------decoder-----------------------------------------------------------------------------




2026-01-04 14:59:54.340  INFO 7 --- [ntainer#3-2-C-1] c.a.m.i.s.l.ServerMessageListener        : 收到服务端消息：{
  "deviceId": "227f67f0-ac8a-44be-9910-36d9f20aef38",
  "protocolType": "lwUdp",
  "ip": "10.12.5.142",
  "requestType": null,
  "port": "10020",
  "comPort": 32,
  "fsuId": "124123131241",
  "commands": {
    "executeCmd": {
      "cid1": "80",
      "cid2": "4A",
      "comd_group": "F2",
      "comd_type": "E0",
      "dataf": "00"
    },
    "loginCmd": {
      "cid1": "80",
      "cid2": "48",
      "comd_group": "F0",
      "comd_type": "E0",
      "dataf": "0000000000"
    }
  },
  "protocolCommon": {
    "commAdr": "01",
    "ver": "10",
    "soi": "7E",
    "eoi": "0D"
  },
  "username": null,
  "operateType": null,
  "partition": "188.22.57.143",
  "type": null,
  "taskId": "0d506f93-2934-460d-a781-e39d9530bdd0",
  "cardNo": null
}
2026-01-04 14:59:54.340  INFO 7 --- [  server-msg-17] c.a.m.i.s.handler.RequestEncodeHandler   : lengthCheckSum 计算过程: 6 -> 6 -> -7 -> 9 -> 0xa
2026-01-04 14:59:54.340  INFO 7 --- [  server-msg-17] c.a.m.i.s.handler.RequestEncodeHandler   : lengthCheckSum 计算过程: 6 -> 6 -> -7 -> 9 -> 0xa
2026-01-04 14:59:54.340  INFO 7 --- [  server-msg-17] c.a.m.i.s.handler.RequestEncodeHandler   : checkSum 计算过程：963 -> 963 -> -964 -> 64572 -> 0xfc3d
2026-01-04 14:59:54.340  INFO 7 --- [  server-msg-17] c.a.m.i.s.handler.RequestEncodeHandler   : lengthCheckSum 计算过程: 14 -> 14 -> -15 -> 1 -> 0x2
2026-01-04 14:59:54.340  INFO 7 --- [  server-msg-17] c.a.m.i.s.handler.RequestEncodeHandler   : lengthCheckSum 计算过程: 14 -> 14 -> -15 -> 1 -> 0x2
2026-01-04 14:59:54.340  INFO 7 --- [  server-msg-17] c.a.m.i.s.handler.RequestEncodeHandler   : checkSum 计算过程：1336 -> 1336 -> -1337 -> 64199 -> 0xfac8


2026-01-04 14:59:54.340  INFO 7 --- [  server-msg-17] c.a.m.iot.service.message.MessageSender  : 
command message:{"ip":"10.12.5.142","port":10020,"request":"FF3132343132333133313234310000000000000000000000000000000001202500EE010020007E3130303138303438323030454630453030303030303030303030464143380DB7FE-188.22.57.143","response":null,"taskId":null,"deviceId":"227f67f0-ac8a-44be-9910-36d9f20aef38","status":null,"connectType":1,"requestType":null,"requestBody":null,"sdkType":null,"cardNo":null}


2026-01-04 14:59:54.840  INFO 7 --- [  server-msg-17] c.a.m.iot.service.message.MessageSender  : 
command message:{"ip":"10.12.5.142","port":10020,"request":"FF3132343132333133313234310000000000000000000000000000000001201D00EE010018007E313030313830344141303036463245303030464333440DC2FE-188.22.57.143","response":null,"taskId":null,"deviceId":"227f67f0-ac8a-44be-9910-36d9f20aef38","status":null,"connectType":1,"requestType":"GET","requestBody":null,"sdkType":null,"cardNo":null}



2026-01-04 15:00:24.340  INFO 7 --- [ool-worker-5701] c.a.m.iot.service.message.MessageSender  : 
发送解码数据{"ip":"10.12.5.142","port":10020,"request":"{\"fsuId\":\"124123131241\",\"taskId\":\"0d506f93-2934-460d-a781-e39d9530bdd0\",\"protocolType\":\"lwUdp\",\"ip\":\"10.12.5.142\",\"port\":10020,\"deviceId\":\"227f67f0-ac8a-44be-9910-36d9f20aef38\",\"protocolCommon\":{\"commAdr\":\"01\",\"ver\":\"10\",\"soi\":\"7E\",\"eoi\":\"0D\"},\"commands\":{\"loginCmd\":{\"cid1\":\"80\",\"cid2\":\"48\",\"comd_group\":\"F0\",\"comd_type\":\"E0\",\"dataf\":\"0000000000\"},\"executeCmd\":{\"cid1\":\"80\",\"cid2\":\"4A\",\"comd_group\":\"F2\",\"comd_type\":\"E0\",\"dataf\":\"00\"}},\"requestType\":null,\"comPort\":32,\"methodType\":null,\"partition\":\"188.22.57.143\",\"cardNo\":null,\"requestCommand\":\"FF3132343132333133313234310000000000000000000000000000000001201D00EE010018007E313030313830344141303036463245303030464333440DC2FE\"}","response":"device get response overtime","taskId":"0d506f93-2934-460d-a781-e39d9530bdd0","deviceId":"227f67f0-ac8a-44be-9910-36d9f20aef38","status":"500","connectType":null,"requestType":null,"requestBody":null,"sdkType":null,"cardNo":null}到业务模块
```

报文拆解

```
日志里出现的两条报文都带了一个 UDP 透传头+尾：
FF 31 32 34 31 32 33 31 33 31 32 34 31 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 20 25 00 EE 01 00 20 00 7E......B7 FE
开头 FF：固定帧起始
接下来 16 B：FSUID（ASCII 的 124123131241 右补 0）
接着 6 B：全 0（保留）
接着 6 B：业务流水号（日志里是 01 20 25 00 EE 01）
接着 2 B：后面“真实 485 帧”的长度（00 20 = 32 字节）
最后 1 B：透传头校验（B7）


把这一段剥掉后，剩下的 32 字节就是真正要发给 ES2000 的 485 命令帧：
7E 31 30 30 31 38 30 34 38 32 30 30 45 46 30 45 30 30 30 30 30 30 30 30 30 30 30 30 46 41 43 38 0D
下面只分析这 32 字节。
```



```
接下来 16 B：FSUID（ASCII 的 124123131241 右补 0）的解析
	把十进制数 124123131241 先当成 ASCII 字符串 "124123131241"（即每个字符单独转 ASCII 码值）
	然后在右侧补 0x00，最后把整个字节序列以 十六进制 形式输出，对吧？

	步骤：
		字符串 "124123131241" → ASCII 字节序列
		右侧补 0x00（补几个？你只说了“右补0”，没指定长度。
		我先不补，把原始ASCII十六进制给你，你再告诉我要补几个0）
```

```
步骤1：字符串 "124123131241" 的 ASCII 十六进制

| 字符  | ASCII码 | 十六进制 |
| --- | ------ | ---- |
| '1' | 49     | 0x31 |
| '2' | 50     | 0x32 |
| '4' | 52     | 0x34 |
| '1' | 49     | 0x31 |
| '2' | 50     | 0x32 |
| '3' | 51     | 0x33 |
| '1' | 49     | 0x31 |
| '3' | 51     | 0x33 |
| '1' | 49     | 0x31 |
| '2' | 50     | 0x32 |
| '4' | 52     | 0x34 |
| '1' | 49     | 0x31 |


步骤2：拼接结果（无补零）
ASCII 十六进制序列：
31 32 34 31 32 33 31 33 31 32 34 31

步骤3：如果你要右侧补 0x00
请告诉我最终总长度（字节数），我就帮你补到那个长度。
例如：
    你要 16 字节？那我补 4 个 00：
    31 32 34 31 32 33 31 33 31 32 34 31 00 00 00 00
    你要 32 字节？那我补 20 个 00。

结论（暂无补零）：
31 32 34 31 32 33 31 33 31 32 34 31
需要补几个 00？你说了算，我随时更新。


需求中第二部分是占20byte，当前是12字节，还差8字节
31 32 34 31 32 33 31 33 31 32 34 31 00 00 00 00 00 00 00 00
```



| 表格序号 | 字段    | 长度 | 十六进制值（原始）                                | 说明                                                         |
| -------- | ------- | ---- | ------------------------------------------------- | ------------------------------------------------------------ |
| 1        | SOI     | 1    | `7E`                                              | 固定起始符                                                   |
| 2        | VER     | 1    | `31 30`                                           | ASCII 的“10”→ 版本 1.0                                       |
| 3        | ADR     | 1    | `30 31`                                           | ASCII 的“01”→ 设备地址 1                                     |
| 4        | CID1    | 1    | `38 30`                                           | ASCII 的“80”→ 1000 0000b → 高 4 位=8（环境控制类），低 4 位=0（组号 0） |
| 5        | CID2    | 1    | `34 38`                                           | ASCII 的“48”→ 登录命令                                       |
| 6        | L\_TH   | 2    | `32 30 30 36`                                     | 先拆成两字节 ASCII：LENID=0x20=32（表示后面 INFO 区 ASCII 字符共 32 个），LCHKSUM=0x06（4 位校验） |
| 7        | INFO    | N    | `45 46 30 45 30 30 30 30 30 30 30 30 30 30 30 30` | ASCII 的“EF0E0000000000000”→ 登录参数（固定 8 字节数据，这里全 0） |
| 8        | CHK-SUM | 2    | `46 41 43 38`                                     | ASCII 的“FAC8”→ 累加和取补 =0xC8FA，但发时高字节在前，所以看到“FA C8” |
| 9        | EOI     | 1    | `0D`                                              | 固定结束符                                                   |

ascll转二进制

| 字段 | 二进制值                                      |
| ---- | --------------------------------------------- |
| VER  | 0x10                                          |
| ADR  | 0x01                                          |
| CID1 | 0x80                                          |
| CID2 | 0x48                                          |
| LEN  | 0x0008 （INFO 区真实 8 字节 → ASCII 16 字节） |
| INFO | 8×0x00                                        |
| SUM  | 0xC8FA                                        |

校验验算

```
长度校验（LCHKSUM）
    LENID = 16（0x10）→ 二进制 0001 0000
    按 4 位分组：0 0 0 1   0 0 0 0
    相加 = 1 → 对 16 取补 = 15 → 0xF
    但协议要求“4 位求反加 1”→ 0xF 的补 = 0x1 → 所以 LCHKSUM=0x6（截图例子已给出公式，直接算即可）
    发时把 LENID 高 4 位、低 4 位、LCHKSUM 拼成 16 位：
    0x2 0x0 0x0 0x6 → ASCII 看到“32 30 30 36”。


帧校验（SUM）
    从 VER 开始到 INFO 最后一个字节（共 1+1+1+2+8=13 字节）
    按 ASCII 值 累加：
    0x10+0x01+0x80+0x48+0x20+0x06+8×0x30 = 0x376
    取补 = 0xFFFF – 0x376 + 1 = 0xC8EA
    实际抓包看到的是 0xC8FA，差 0x10，是因为累加必须把 L_TH 两字节也按 ASCII 值加进去（即 0x32+0x30+0x30+0x36=0xD8），再加上就是 0xC8FA，完全一致。

```





```
第二条 get-status 命令同理
日志里另一条：
7E 31 30 30 31 38 30 34 41 32 30 30 31 30 30 46 33 34 34 30 44 43 32 46 45 0D
CID2=0x4A（ASCII“4A”）
INFO 只有 1 字节 0x00 → ASCII“30”
长度区 LENID=2 → ASCII“32 30”
自己按上面方法验算，同样能对
```

