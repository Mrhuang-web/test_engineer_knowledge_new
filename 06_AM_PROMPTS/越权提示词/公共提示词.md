接口越权测试可以拆成“三步走”：先分类→再设计→最后定位。下面把方法论、用例模板、工具技巧一次给全，直接照抄就能用。

------------------------------------------------
一、越权分类与典型场景  
1. 未授权访问：根本没登录就能调通接口。  
2. 水平越权：同级账号 A 越权访问/操作 B 的数据。  
3. 垂直越权：低权限账号越权调用高权限接口（如普通用户调管理员删除接口）。  

------------------------------------------------
二、测试设计 4 板斧  
| 板斧 | 设计要点 | 快速用例模板 |
|---|---|---|
| ① 角色矩阵 | 把系统“角色×接口”拉成二维表，每个格子写期望状态码（200/403） | 普通用户→管理员接口：期望 403；实际 200→BUG |
| ② 参数替换 | 把 URL、Header、Body 里一切“身份标识”列成变量：uid、orgId、branchCode、roleId… | 用 A 账号登录→把 uid 改成 B 的→重放；返回 200 即水平越权 |
| ③ 会话互换 | 同一条请求，把高权限 Cookie/Token 换成低权限的，看能否调通 | 高权限请求→Token 换低权限→重放；成功即垂直越权 |
| ④ 脏 URL 扫描 | 用爬虫/字典把所有“可能的后台地址”扫一遍，不带任何认证 | 直接 GET /admin/userList → 200 即未授权 |

------------------------------------------------
三、快速执行 3 件套  
1. Burp + Auth Analyzer  
   - 高权限账号在内置浏览器走一遍业务→插件自动录制→一键“Repeat all requests”换低权限 Session→结果面板直接标红越权接口。  
2. Postman 半自动化  
   - 登录接口 Tests 里写  
     `pm.environment.set("token_low", pm.response.json().token)`  
   - 集合 Runner 里把 uid、token 设成变量文件，批量跑 100 条→看断言是否 403。  
3. 命令行 3 行脚本  
   ```bash
   # 水平越权快速验证
   TOKEN_A=eyJxxx
   TOKEN_B=eyJyyy
   curl -H "Authorization: Bearer $TOKEN_A" https://api.xxx/order/123   # 自己的
   curl -H "Authorization: Bearer $TOKEN_A" https://api.xxx/order/456   # 别人的
   ```

------------------------------------------------
四、定位技巧（报 bug 不背锅）  
1. 先排除“假越权”：把 uid 改成不存在的 99999，如果仍 200→接口本身没做鉴权，不是越权而是裸奔。  
2. 看返回体：  
   - 只有 code=403 但 msg=“权限不足”→前端/网关拦的，后端可能还裸着。  
   - code=200 但 data=null→后端做了数据权限，可写“已校验，无数据泄露”。  
3. 日志关联：把请求时间戳→后端 access.log→搜索对应 traceId，看是否走到 @PreAuthorize/@RequiresPermissions 注解，快速确认是哪一层漏判。  
4. 一行 SQL 验证（需 DB 权限）：  
   ```sql
   SELECT created_by FROM orders WHERE id=456;
   -- 如果 created_by ≠ 当前登录用户→后端缺数据权限校验
   ```

------------------------------------------------
五、最小复测清单（上线前 5 分钟）  
| 检查项 | 通过标准 |
|---|---|
| 1. 未登录直接调接口 | 全部 401 |
| 2. 同级 A→B 数据 | 全部 403/404 |
| 3. 低权→高权接口 | 全部 403 |
| 4. 改 URL 参数（uid、roleId、orgId） | 全部 403 |
| 5. 改 Body 参数（hidden 字段、isAdmin=true） | 全部 403 |

全部绿勾即可签字上线，有红字按上面定位流程 2 分钟就能锁定是哪层鉴权漏了。