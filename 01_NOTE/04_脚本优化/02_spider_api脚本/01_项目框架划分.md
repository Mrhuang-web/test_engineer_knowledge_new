# 框架划分

```
基本框架目录
    report
    apischeme
    	json格式测试用例数据：需要用common的all_excelcase...这个工具读取
    testdata
    	xlsx格式测试用例数据，也可以直接用common的all_excelcase...这个工具读取
    TestCase
    	测试用例
    conf
    	config.ini[不同环境服务器，数据库等连接的信息 -- 静态的]
	conftest.py[最外层有，然后每个测试目录层里面也有，根据不同需求来定，内部还有的那个那部分就只读内部]
		胶水文件 -- 用于初始化和结束的一些处理
	pytest.ini
		配置启动时的一些相关配置
	run.py
		全用例跑自动化
	debug.py
		指定用例跑自动化，检测
	TestEnv.py
		不同环境，需要的登录用户、项目需要的东西[config.ini是前提 -- 动态的]
	
扩展工具
	log
	har2case[读f12接口录制保留的har文件转yaml测试用例]
		待补充
	common[公共类]
		items[菜单集合-各省份和集团都不同]
		testcript[造数-所有平台共用]
		Log、es、request、assert、casebase[等封装-所有平台共用]
	aspire[特点模块的辅助类]
		ciper -- 加解密
		datetime -- 获取时间方式
		jsonhelper -- 对json读写转换断言json等操作
		jsonlibrary -- 对json增删改查转
		mysqlpool -- mysql连接池
		redishelper -- redis连接、增删改查
		regxhelper -- 正则匹配（uuid解析）
		Testcase -- json测试用例解析请求头、请求体、响应体
		utillibary -- 数据库数据转换、md5加密等
		xlsxhelper -- xlsx文件的读取，行读取工具
	logical[目前测试用例大多调这里的]
		用户登录token
		加解密
		数据库处理
		函数过滤等工具
```

# 案例刨析

```

全局定义
    env="guangdong"
    PasAddr = "PasAddr_" + 'guangdong_sc'
    db_pas = "db_pas_" + 'guangdong_sc'
    conn_obj=MySQLHelper(TestEnv.ServerConfig[db_pas])
    server = TestEnv.ServerConfig[PasAddr]
    logger = get_instance()
    
apischeme -- api规则模板，每个接口对应一个
    dataFile = os.path.join(
        os.path.dirname(
            os.path.dirname(
                os.path.dirname(
                    os.path.dirname(__file__)))),
            "testdata",
            'guangdong',
            "%s.xlsx" %
            ('fsumanage'))
            

测试用例类定义
    @allure.epic("FSU管理-FSU阈值配置")
    class Test_fsumanage(object):
        '''
        FSU管理-FSU阈值配置
        '''
        
测试用例类 - 类变量文件 - 测试用例共用
    data1 = datadriver.load_data_from_excel(dataFile, 0, TestEnv.exeFilter)
    
    
测试用例类 - 初始和销毁
    def setup_class(self):
        MySQLHelper(TestEnv.ServerConfig[db_pas]).execute("update wb_config_platform set value = 'false' WHERE NAME='is-check-on';")
        self.cookie = ams_login_by_passwd(username='autotest_high', passwd=TestEnv.users['autotest_high'], server=server)
        self.cookie_low = ams_login_by_passwd(username='autotest_low', passwd=TestEnv.users['autotest_low'], server=server)
        self.cookie_flat = ams_login_by_passwd(username='autotest_flat', passwd=TestEnv.users['autotest_flat'], server=server)

    def teardown_class(self):
        MySQLHelper(TestEnv.ServerConfig[db_pas]).execute("update wb_config_platform set value = 'true' WHERE NAME='is-check-on';")

    
    
测试用例 - 会过滤比类变量文件
	@pytest.mark.parametrize('cdata', filtercases(data1, "test_fsumanage_v1_fsumanage_fsuAlert_listMete"))
    def test_fsumanage_v1_fsumanage_fsuAlert_listMete(self, cdata):
        case_params, action = spider_common.common_step_f_withoutAssert(cdata, server=server, jfile_scheme=api_scheme_name1, cookie=self.cookie)
        #spider_common.writeResultToExcel(cdata=cdata, url_path=action.url_path, req_header=action.headers, req_body=action.req_body, resp_body=action.resp_body, dataFile=dataFile)
        action.assert_http_status_code(cdata[8])
        assert action.resp_body is not None, "响应体为空"
        if isinstance(action.resp_body, dict):
            if 'status' in action.resp_body:
                action.assert_body_by_data_x(cdata[9])

```

### 测试用例分步解析

```
1、@pytest.mark.parametrize(xx,filtercases(data,""))
	参数化获取执行用例：过滤全局文件内属于本次测试用例函数的 用例
	
2、def test_fsumanage_v1_fsumanage_fsuAlert_listMete(self, cdata)
	测试用例：接收参数化测试用例
	
3、case_params, action = spider_common.common_step_f_withoutAssert()
	测试用例执行：调用封装的测试步骤 -- 需要测试用例数据、服务信息、api规则、cookie信息
	

4、action.assert_http_status_code(cdata[8])
	测试用例执行后请求校验：校验响应状态码
	
5、assert action.resp_body is not None, "响应体为空"
	测试用例执行后响应体校验：校验响应提是否有内容

6、if isinstance(action.resp_body, dict):
	测试用例执行后响应体类型校验：校验响应类型是否为字典

7、if 'status' in action.resp_body:
	测试用例执行后响应体内状态校验：校验响应里面是否有状态
	
8、action.assert_body_by_data_x(cdata[9])
	测试用例执行后响应体内状态校验：校验响应里面状态码是否一致
```

底层逻辑

```
3、case_params, action = spider_common.common_step_f_withoutAssert()的底层

	common_step_f_withoutAssert(cdata, server=TestEnv.ServerConfig['PasAddr'], jfile_scheme="", cookie=None):


    with allure.step('step 0: 处理用例基本信息，未实现用例跳过不执行'):
        dymtitle = f"VerID:{cdata[0]}|ReqID:{int(cdata[1])}|Author:{cdata[2]}|CaseTitle:{cdata[3]}"
        allure.dynamic.title(dymtitle)
        logger.info('\n%s:%s' % (cdata[0], cdata[3]))
        if "no" in cdata[-1].lower():
            pytest.skip("用例未实现，略过不执行")
    
    
    
    # 即文件每行的数据【以下都是文件的每行数据】
    
    
    
    with allure.step('step 1: 加载公共参数'):
        if isinstance(cdata[5], str) & (len(cdata[5]) > 0):
            case_params = datadriver.from_str_to_params(cdata[5])
        else:
            case_params = {}
        logger.info(f'公共参数是:\n{case_params}')
    
    
    # 构建请求 -- 都是同个类去调用
    with allure.step('step 2: 初始化接口请求结构信息'):
        action = SpiderLogic(
            server=server,
            jfile_scheme=jfile_scheme,
            case_params=case_params)
    
    
    # 更新请求头的数据
    with allure.step('step 3: 更新用例相关的请求头数据'):
        headers_info = cdata[6]
        if isinstance(headers_info, str) & (len(headers_info) > 0):
            action.update_headers(headers_info, case_params)
        if cookie is not None:
            action.update_headers(cookie)
    
    
    with allure.step('step 4: 更新用例相关的请求消息体'):
        if isinstance(cdata[7], str) & (len(cdata[7]) > 0):
            if action.method == "POST":
                action.update_text_to_body(cdata[7], case_params)
            if action.method == "GET":
                cdata[7] = xutils.handle_regx_in_text(cdata[7], case_params)
                action.url_params = cdata[7]

    with allure.step('step 5: 向服务器请求消息'):
        # 可以在接口或项目逻辑中扩展快照
        # action1.backup_data()
        action.send()
        # action1.backup_data()
        action.retrieved_body_to_params(case_params)
        logger.info(case_params)
    
    
    with allure.step('step 6: 项目特殊的业务逻辑校验'):
        pass
        # action.assert_body_by_data(cdata[9])
        # action1.assert_createorupdate_success()
   
   
   return case_params, action
```

